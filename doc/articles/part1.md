#Tracing - your println 2.0.

(Note: this is work in progress and needs a lot of improvements)

This article is trying to to introduce the concept of tracing for application developers.
It is focused on tools available in Linux ecosystem. It is *not* about debugging Linux kernel, as there is a lot
of guides and talks covering this subject.

1. What do I mean by tracing?

Tracing provides ability for interested people to look into details of program internals and extract usable information
while the program is running, without changing its code or configuration, without restarting it, with minimal influence on performance and with no risk of causing problems. Those features are crucially important for debugging problems in environments that
cannot stand a downtime or are not under control of person performing debugging. Popular tracing tools include Dtrace, BPF, or ETW for Windows, though there are many others. For now this article is focused on Linux tools.

2. How does that work in general.

General idea is that you have a set of points of interest - places were potentially interesting things are happening in your application. This can be where your code is accepting new connection, handles web request, opens a file - whatever might be relevant for your code. Some of those places can be automatically recognized by Linux (if it has enough knowledge about them), some may require adding special annotations to mark them. Normally presence of such markers has no effect - they are not affecting performance, they do not execute any additional code, and should not be in any way noticeable, unless you want start tracing.
This is when things are becoming interesting. When that happens, Linux kernel take over control and executes special code that hooks into your point of interest, gathers whatever information it may find useful, and exports relevant metrics.
This "special code" is generated by tools like BPF, verified by kernel to be safe (it cannot perform writes or loops, among other restrictions), and executed in the context of your application. It may sound complicated, but using it is actually very simple.

3. How specifically it works in Linux

I am using "tracing" as an umbrella name for a set of technologies that make it possible.
While they all work well together, there were - and still are - developed independently, and some of them may be enhanced or replaced if needed.

To understand tracing in Linux, you need to understand following parts:

* probes. Those are your "points of interest". There are many types of probes, including kernel probes, shared object function calls and others. Some of them come from places Linux already knows about, some have to be specifically declared. I will not list all of them here, but one is particularly relevant for developers:
* USDT probes. Those are markers you can insert into any place in your application, give it a name and a list of arguments,
and that way they will work with all Linux tracing tools. An example of using probe in your C/C++ code will look like that:

```C
DTRACE_PROBE1(foo, bar, i)

```
defining probe provided by "foo" provider, under name "bar", and having one argument (exposed arguments don't have names, "i" refers to some variable in this program). Having done that, you can use tools like bcc to for example find out how many times this probe is being hit per second:

```sh
sudo funccount -i 1 'u:foo:bar'
```
USDT probes are described in ```notes``` section of ELF file (including shared object) and easily discoverable.

* BPF - a mechanism to execute tracing code. When tools like funccount or trace want to gather some metrics,
they generate program made of BPF bytecode and send it to kernel to execute when particular event will happen.
Kernel will verify that this program is safe to run (it only contains safe instructions, does not exceeds allowed limits and so on),
manages its execution and returns the result. This is meant to be safe, and perform well even if you trace thousands of events per second.

* maps - datastructures to which BPF programs can write their metrics. There are various types of maps (arrays, hashmaps, bloom filters). This is the only way for a BPF code to write or expose any data.

* Frontend tools like funccount, ply, trace, and many others. Those user-space tools generate BPF code, send it to kernel, read data from maps and present results to users. Currently most popular tool collection is provided by [bcc](https://github.com/iovisor/bcc), but 
anyone can create their own, and there is nothing mandating use bcc if you want to do that, though it is very extensible base for that.
Note that unlike DTrace, Linux doesn't have a concept of one syntax. Any tool can generate BPF code from whatever form they want.

3. Linux vs DTrace

DTrace was a proprietary tool providing  unified name and distribution of equivalent of all components described above. While opensourced at some point, for various historical reasons it never got popular on Linux. It was widely known as the only tool in its class some time ago, some people use it as synonym for tracing, and the name prevailes in some forms on Linux (C macro defining USDT probes is called DTRACE_PROBE for compatibility, even though implementation has nothing to do with DTrace). It is available and widely used on Mac and BSD systems). Generally as an application developer, you may define your probes in an implementation-independent manner, and expect it to be understood by whatever implementation exist on the terget platform, be it DTrace, USDT or something else.

Q: Don't we have debuggers to do that?

Debugging is heavily affecting performance, can be destructive and often requires intimate knowledge of source code,
as well as programming in general. It's great tool, but not for every occasion.


Q: But I can just print what I want in my code, why would I need anything else?

A: As an author of your application, you indeed can, and it may be the best way for you to fix the problem,
if you are using your computer.
However tracing is often performed in environments you don't control (like your customers servers),
by people who do not have access to source code, skills and confidence to modify it, or even tools to do it
(production environments often may not have compilers installed), under pressure of time. Also some problems
happen only in particular circumstances, and are hard to reproduce, so restarting your application
may cause the problem to go away, without giving you a chance to observe it while it is happening.


Q: But there are logs, don't they provide enough information?

A: Logs are useful and you should have them, but they are often insufficient to diagnose problems.
First of all, not all programs allow to modify what information is logged without restart.
This leads to conservatime logging most of the time, and a need to restart the application if there is specific problem.
Second, logs contain information you spefically expect to be useful, and thus log statement are typically rather rare.
In contrast, tracing is expected to be applied in many places in your code, even if the chance of it being used is one in a million,
because the cost of doing so is minimal, and when you look for a source of particular problems, anything could be responsible.

Third, people using your application have no way of deciding where do you insert log statement.

Another problem with logs is that they require exporting data out of your application. With high-speed networks, any
attempt to print every data packet will fail miserably. Tools like BPF and DTrace however allow you to
run code generating summary of things that interest you and only export that. You can easily count
how many certain types of packets are sent, inspecting all of them, and only exporting the counter.

Q: I'm interested in including probes in my code, how can I do it?

A: There are few ways to do that. First, Linux already knows about functions present in your code,
as well as all functions present in shared objects used by applications. Providing
a nicely named function name is a good start and in many cases is really all you need to do.

For example if inform yout users that you have a function named "accept_connection" and it is called
whenever a connection is accepted, its enough information to be useful for tracing,
without much work on your side.

You can do better though with USDT probes. Those are usually inserted into your code with macros,
though details may depend on your programming language and libraries that are available.
You should link your code with appropriate libraries that will generate probes, insert macro in relevant places,
and document when it is executed and the meaning of its arguments, if there are any.

